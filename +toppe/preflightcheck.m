function preflightcheck(entryFile, seqstampFile, sys)
% function preflightcheck(entryFile, seqstampFile, sys)
%
% Generate 'sequence stamp' file containing file checksums,
% and patient- and scanner-related safety-related information.
% Do not edit that file by hand as it impacts safety checks!
%
% This function loads the various TOPPE files listed in entryFile 
% and the file listed in line 2 in entryFile (e.g., 'modules.txt'),
% and populates 'seqstampFile' with miscellaneous sequence information related to 
% peak gradient/slew, peak 10-sec SAR (equivalent TR), and gradient heating.
% The various files listed in entryFile and modules.txt must be present
% in the current working folder.
%
% Inputs:
%   entryFile      (string) This file is the entry point for the TOPPE interpreter,
%                  and MUST be copied to /usr/g/research/pulseq/ on the scanner host.
%                  The various files listed in entryFile and modules.txt must be present
%                  in the current Matlab working folder.
%   seqstampFile   (string) Output file name. Must be listed in line 6 of entryFile.
%   sys            GE system struct. See toppe.systemspecs().
%
% Example usage:
%  Step 1: Create the file 'toppe0.entry' by hand, and copy to /usr/g/research/pulseq/
%          on the scanner host computer. See examples/3DGRE/ for an example.
%  Step 2: Define the system hardware parameters
%     >> sys = toppe.systemspecs();  % use default system limits. This is usually not a good idea!
%  Step 3: Create the file 'seqstamp.txt'
%     >> preflightcheck('toppe0.entry', 'seqstamp.txt', sys);
%  Step 4: Copy all scan files to the scanner host computer, in the path stated in
%          line 1 of toppe0.entry. For the 3D GRE example, these files are:
%          modules.txt, scanloop.txt, tipdown.mod, readout.mod, and seqstamp.txt
%  Step 5: Prescribe the interpreter and scan, following the README in the
%          interpreter code repository.

fprintf('Preflight check (for GE)...\n');

% open output file
fout = fopen(seqstampFile, 'w');

% Write file preamble
fprintf(fout, 'DO NOT EDIT THIS FILE.\n\n');
fprintf(fout, 'Sequence ''stamp'' file used by TOPPE interpreter\n');
fprintf(fout, 'to perform patient and hardware safety checks.\n');
fprintf(fout, 'This file was generated by %s.m\n\n', mfilename);

% get scan file names
fid = fopen(entryFile, 'r');
if fid == -1
    error('Failed to open entry file');
end
fpath = fgetl(fid);  % location of TOPPE scan file -- don't need it here
moduleListFile    = fgetl(fid);    % e.g., 'modules.txt'
loopFile          = fgetl(fid);    % e.g., 'scanloop.txt'
b1CheckFile       = fgetl(fid);    % .mod file used for b1 scaling and SAR checks, e.g., 'tipdown.mod'
readoutFilterFile = fgetl(fid);    % .mod file used to set receive filter, e.g., 'readout.mod'
fclose(fid);

% Get modules.
% This step also checks the formatting of the module list file.
modArr = toppe.tryread(@toppe.readmodulelistfile, moduleListFile);

% Check that:
%  - all .mod files use the same peak RF limit (e.g., 0.25 Gauss)
%  - all .mod files used to acquire data have the same number of ADC samples as readoutFilterFile.
[~,~,~,~,~,~,~,hdr] = toppe.readmod(b1CheckFile);
b1limit = hdr.b1max;
[~,~,~,~,~,~,~,hdr] = toppe.readmod(readoutFilterFile);
ndaq = hdr.rfres;   % number of 4us samples to acquire
for ii = 1:length(modArr)
    [~,~,~,~,~,~,~,hdr] = toppe.readmod(modArr{ii}.fname); 

    if modArr{ii}.hasDAQ & hdr.rfres ~= ndaq
        error(sprintf('Number of samples in %s and %s do not match (must be same across all .mod files containing ADC windows)', ...
            readoutFilterFile, modArr{ii}.fname));
    end
    if hdr.b1max ~= b1limit 
        error(sprintf('B1 limit in %s does not match %s (must be the same across all .mod files)', ...
            modArr{ii}.fname, entryFile));
    end
end

% Get peak gradient and slew across all .mod files.
% This also issues any PNS warnings (in checkwaveforms).
gmax = 0;
slewmax = 0;
for ii = 1:length(modArr)
    [~,gx,gy,gz,~,~,~,~] = toppe.readmod(modArr{ii}.fname); 
    [isValid, gmaxtmp, slewmaxtmp] = toppe.checkwaveforms(sys, ...
        'gx', gx, 'gy', gy, 'gz', gz);
    if ~isValid
        error('checkwaveforms failed for module %d', ii);
    end
    gmax = max(gmax, max(gmaxtmp));
    slewmax = max(slewmax, max(slewmaxtmp));
end

% write file checksums
[status, cs] = eval(sprintf('system("md5sum %s | cut -d '' '' -f 1")', moduleListFile    ));
fprintf(fout, '%s', cs);  % cs contains trailing newline
[status, cs] = eval(sprintf('system("md5sum %s | cut -d '' '' -f 1")', loopFile          ));
fprintf(fout, '%s', cs);
[status, cs] = eval(sprintf('system("md5sum %s | cut -d '' '' -f 1")', b1CheckFile       ));
fprintf(fout, '%s', cs);
[status, cs] = eval(sprintf('system("md5sum %s | cut -d '' '' -f 1")', readoutFilterFile ));
fprintf(fout, '%s', cs);
fprintf(fout, '%d\n', length(modArr));  % number of .mod files ('cores' in .e file)
for ii = 1:length(modArr)
    [status, cs] = eval(sprintf('system("md5sum %s | cut -d '' '' -f 1")', modArr{ii}.fname));
    fprintf(fout, '%s', cs);
end

% Calculate 'equivalent' TR (TRequiv) corresponding to worst-case 10-sec SAR.
% Assumes use of the RF pulse in 'b1CheckFile'.  
% (TODO: consider replacing with a fixed reference pulse, e.g., 90 deg tbw=6 dur=2.3ms sinc as in 3dgrass.e)
% To stay within SAR limits, TRequiv must be greater than the value returned by 'maxseqsar' in the EPIC code.
% Also calculate gradient power = energy per TRequiv.
% Do it in small chunks to limit memory usage.
d = toppe.readloop(loopFile);
nStartseq = size(d,1);   % number rows in scanloop.txt (= number of 'startseq' calls in the EPIC code).
dt = 4e-6;         % RF raster time (sec)
nStartseqPerIter = 5000;
nit = ceil(nStartseq/nStartseqPerIter);
peaksar = 0;
peakgxes = 0;
peakgyes = 0;
peakgzes = 0;
for ii = 1:nit
    for ib = 1:30
        fprintf('\b');
    end
    fprintf('\titer %d of %d', ii, nit);
    iStart = (ii-1)*nStartseqPerIter + 1;
    iStop = min(ii*nStartseqPerIter + 1000, nStartseq); % overlap a bit
    [b1, gx, gy, gz] = toppe.plotseq(iStart, iStop, sys, ...
        'loopFile',       loopFile, ...
        'moduleListFile', moduleListFile, ...
        'doDisplay',      false);
    b1s = abs(b1).^2;    % RF power waveform (energy per 4us sample)
    gxes = gx.^2;        % gradient power waveform (energy per 4us sample)
    gyes = gy.^2;        % gradient power waveform (energy per 4us sample)
    gzes = gz.^2;        % gradient power waveform (energy per 4us sample)
    n10s = round(10/dt);  % number of rf samples in 10s
    if length(b1s) > n10s
        b1s = movmean(b1s, n10s, 'Endpoints', 'discard');
        peaksar = max(peaksar, max(b1s));
        gxes = movmean(gxes, n10s, 'Endpoints', 'discard');
        gyes = movmean(gyes, n10s, 'Endpoints', 'discard');
        gzes = movmean(gzes, n10s, 'Endpoints', 'discard');
        peakgxes = max(peakgxes, max(gxes));
        peakgyes = max(peakgyes, max(gyes));
        peakgzes = max(peakgzes, max(gzes));
    else
        peaksar = mean(b1s)/n10s*length(b1s);
        peakgxes = mean(gxes)/n10s*length(b1s);
        peakgyes = mean(gyes)/n10s*length(b1s);
        peakgzes = mean(gzes)/n10s*length(b1s);
    end
end

rf = toppe.readmod(b1CheckFile);
energy = sum(abs(rf).^2) * dt;  % energy per RF pulse
TRequiv = 2*floor(1e6 * energy / peaksar / 2);     % microsec
powerx = peakgxes * TRequiv;        % (G/cm)^2 * usec. Will be converted to Ampere^2 * usec in the .e file.
powery = peakgyes * TRequiv;        % (G/cm)^2 * usec
powerz = peakgzes * TRequiv;        % (G/cm)^2 * usec

% Print various parameters to file
fprintf(fout, '%d\n', TRequiv);
fprintf(fout, '%d\t%d\t%d\n', round(powerx), round(powery), round(powerz));   % needed in minseq() in the .e file
fprintf(fout, '%.4f\n', max(abs(rf)));  % needed to scale max_seqsar in .e file
fprintf(fout, '%.4f\n', gmax);          % max gradient across all .mod files (Gauss)
fprintf(fout, '%.4f\n', slewmax);       % max slew across all .mod files (G/cm/ms)
fprintf(fout, '%.4f\n', b1limit);       % hardware b1 limit (Gauss) 

fclose(fout);

fprintf(' done\n');

